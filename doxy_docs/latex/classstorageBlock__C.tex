\doxysection{storage\+Block\+\_\+C Class Reference}
\label{classstorageBlock__C}\index{storageBlock\_C@{storageBlock\_C}}


Blocks of storage. eg. 1 block for 1wire chips and another for room data. each of different lengths with different ids.  




{\ttfamily \#include $<$store.\+h$>$}



Collaboration diagram for storage\+Block\+\_\+C\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=550pt]{classstorageBlock__C__coll__graph}
\end{center}
\end{figure}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ storage\+Block\+\_\+C} (byte \textbf{ max\+Blocks}, \textbf{ storage\+Block\+\_\+T} a[$\,$], byte start\+Index=0)
\begin{DoxyCompactList}\small\item\em Pointer to an array used to store each slots details in. \end{DoxyCompactList}\item 
\textbf{ $\sim$storage\+Block\+\_\+C} ()
\item 
void \textbf{ leave\+First} (byte i)
\begin{DoxyCompactList}\small\item\em Set the address to start using storage at. \end{DoxyCompactList}\item 
byte \textbf{ add\+Block} (byte slots, byte rec\+Size)
\begin{DoxyCompactList}\small\item\em Add a storage block. \end{DoxyCompactList}\item 
byte \textbf{ block\+Size} (byte id)
\begin{DoxyCompactList}\small\item\em get the storage space size in bytes reserved for the block. \end{DoxyCompactList}\item 
word \textbf{ block\+Start} (byte block\+Id)
\begin{DoxyCompactList}\small\item\em Get the storage block start address. \end{DoxyCompactList}\item 
word \textbf{ block\+End} (byte id)
\begin{DoxyCompactList}\small\item\em get block end index. i.\+e. the address of last byte used by the block. If block size is 0 there isn\textquotesingle{}t a block end so result will be meaningless. \end{DoxyCompactList}\item 
byte \textbf{ get\+Slots} (byte id)
\item 
byte \textbf{ read\+Byte} (byte block\+Id, byte slot, byte offset)
\begin{DoxyCompactList}\small\item\em Read a byte of data from a storage block slot. \end{DoxyCompactList}\item 
bool \textbf{ read\+Slot} (byte block\+Id, byte slot, void $\ast$r)
\begin{DoxyCompactList}\small\item\em Read a var from permanent storage eg. EEPROM into a var/struct, copys mem of size = to the slot size given when add\+Block was called. \end{DoxyCompactList}\item 
bool \textbf{ write\+Byte} (byte block\+Id, byte slot, byte offset, byte value)
\item 
bool \textbf{ write\+Slot} (byte block\+Id, byte slot, void $\ast$r)
\begin{DoxyCompactList}\small\item\em Write a var into permanent storage eg. EEPROM into a var/struct, copys mem of size = to the slot size given when add\+Block was called. \end{DoxyCompactList}\item 
void \textbf{ print} (byte id)
\begin{DoxyCompactList}\small\item\em print info about the storage block to the serial. \end{DoxyCompactList}\item 
void \textbf{ print\+Mem\+Usage} ()
\end{DoxyCompactItemize}
\doxysubsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
\textbf{ storage\+Block\+\_\+T} $\ast$ \textbf{ blocksA}
\begin{DoxyCompactList}\small\item\em No. of elements of blocksA[] used. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
uint16\+\_\+t \textbf{ next\+Start\+Addr}
\item 
byte \textbf{ max\+Blocks}
\begin{DoxyCompactList}\small\item\em The address/index to start at for any new block. \end{DoxyCompactList}\item 
byte \textbf{ slots\+Used} = 0
\begin{DoxyCompactList}\small\item\em The max No. Blocks. The number of array elements in the array used to store the block info in (blocksA). \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Blocks of storage. eg. 1 block for 1wire chips and another for room data. each of different lengths with different ids. 

Each blocks info if stored in a extern array. 
\begin{DoxyParams}{Parameters}
{\em max\+Blocks} & The size of the array. \\
\hline
{\em a} & a pointer to an extern array used to store the storage info. \\
\hline
{\em start\+Index} & for example with eeprom it could be 15 to stat using the eeprom at address 15; \\
\hline
\end{DoxyParams}


Definition at line \textbf{ 38} of file \textbf{ store.\+h}.



\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\label{classstorageBlock__C_a9020da58b3765ed6bd53da41c55b9eb7}} 
\index{storageBlock\_C@{storageBlock\_C}!storageBlock\_C@{storageBlock\_C}}
\index{storageBlock\_C@{storageBlock\_C}!storageBlock\_C@{storageBlock\_C}}
\doxysubsubsection{storageBlock\_C()}
{\footnotesize\ttfamily storage\+Block\+\_\+\+C\+::storage\+Block\+\_\+C (\begin{DoxyParamCaption}\item[{byte}]{max\+Blocks,  }\item[{\textbf{ storage\+Block\+\_\+T}}]{a[$\,$],  }\item[{byte}]{start\+Index = {\ttfamily 0} }\end{DoxyParamCaption})}



Pointer to an array used to store each slots details in. 

Construct a new storage\+Block class object.


\begin{DoxyParams}{Parameters}
{\em max\+Blocks} & size of the array a[] in elements(not bytes). \\
\hline
{\em a} & Pointer to an array to store the storage block info in. \\
\hline
{\em start\+Index} & index to start using the storage media at. eg. with eeprom, use 15 to skip the first 15 bytes of memory. \\
\hline
\end{DoxyParams}


Definition at line \textbf{ 24} of file \textbf{ store.\+cpp}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00024                                                                                      \{}
\DoxyCodeLine{00025     blocksA = a;}
\DoxyCodeLine{00026     maxBlocks = maxBlocks;}
\DoxyCodeLine{00027     nextStartAddr = startIndex;}
\DoxyCodeLine{00028 \}}

\end{DoxyCode}


References \textbf{ blocksA}, \textbf{ max\+Blocks}, and \textbf{ next\+Start\+Addr}.

\mbox{\label{classstorageBlock__C_afe17040108c5d920b01d871585c150f8}} 
\index{storageBlock\_C@{storageBlock\_C}!````~storageBlock\_C@{$\sim$storageBlock\_C}}
\index{````~storageBlock\_C@{$\sim$storageBlock\_C}!storageBlock\_C@{storageBlock\_C}}
\doxysubsubsection{$\sim$storageBlock\_C()}
{\footnotesize\ttfamily storage\+Block\+\_\+\+C\+::$\sim$storage\+Block\+\_\+C (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Definition at line \textbf{ 29} of file \textbf{ store.\+cpp}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00029 \{ \}}

\end{DoxyCode}


\doxysubsection{Member Function Documentation}
\mbox{\label{classstorageBlock__C_ac9ae09aee8e89280fd15dcae118a7783}} 
\index{storageBlock\_C@{storageBlock\_C}!addBlock@{addBlock}}
\index{addBlock@{addBlock}!storageBlock\_C@{storageBlock\_C}}
\doxysubsubsection{addBlock()}
{\footnotesize\ttfamily byte storage\+Block\+\_\+\+C\+::add\+Block (\begin{DoxyParamCaption}\item[{byte}]{slots,  }\item[{byte}]{rec\+Size }\end{DoxyParamCaption})}



Add a storage block. 

No range checking


\begin{DoxyParams}{Parameters}
{\em slots} & number of slots to add \\
\hline
{\em rec\+Size} & size of each block in bytes. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
byte returns the id of the block. 
\end{DoxyReturn}


Definition at line \textbf{ 107} of file \textbf{ store.\+cpp}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00107                                                         \{}
\DoxyCodeLine{00108     blocksA[ slotsUsed ].start = nextStartAddr;}
\DoxyCodeLine{00109     blocksA[ slotsUsed ].slots = slots;}
\DoxyCodeLine{00110     blocksA[ slotsUsed ].size = recSize;}
\DoxyCodeLine{00111     nextStartAddr += slots * recSize;}
\DoxyCodeLine{00112     slotsUsed++;}
\DoxyCodeLine{00113     \textcolor{keywordflow}{return} slotsUsed -\/ 1;}
\DoxyCodeLine{00114 \};}

\end{DoxyCode}


References \textbf{ blocksA}, \textbf{ next\+Start\+Addr}, \textbf{ storage\+Block\+\_\+\+T\+::size}, \textbf{ storage\+Block\+\_\+\+T\+::slots}, \textbf{ slots\+Used}, and \textbf{ storage\+Block\+\_\+\+T\+::start}.

\mbox{\label{classstorageBlock__C_a2467b7e6f601f96efc42a6c32a023522}} 
\index{storageBlock\_C@{storageBlock\_C}!blockEnd@{blockEnd}}
\index{blockEnd@{blockEnd}!storageBlock\_C@{storageBlock\_C}}
\doxysubsubsection{blockEnd()}
{\footnotesize\ttfamily word storage\+Block\+\_\+\+C\+::block\+End (\begin{DoxyParamCaption}\item[{byte}]{id }\end{DoxyParamCaption})}



get block end index. i.\+e. the address of last byte used by the block. If block size is 0 there isn\textquotesingle{}t a block end so result will be meaningless. 


\begin{DoxyParams}{Parameters}
{\em id} & Block id, index into blocksA[] \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
byte 
\end{DoxyReturn}


Definition at line \textbf{ 48} of file \textbf{ store.\+cpp}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00048                                        \{}
\DoxyCodeLine{00049     \textcolor{keywordflow}{return} blocksA[ id ].start + blocksA[ id ].slots * blocksA[ id ].size -\/ 1;}
\DoxyCodeLine{00050     \textcolor{comment}{//mem for block = number of slots * slot size. }}
\DoxyCodeLine{00051     \textcolor{comment}{//mem used before block = blocksA[ id ].start -\/ 1.}}
\DoxyCodeLine{00052     \textcolor{comment}{// so: i = (blocksA[ id ].start -\/ 1) + blocksA[ id ].slots * blocksA[ id ].size}}
\DoxyCodeLine{00053     \textcolor{comment}{// but as start could be 0 so sub 1 at end.}}
\DoxyCodeLine{00054 \}}

\end{DoxyCode}


References \textbf{ blocksA}, \textbf{ storage\+Block\+\_\+\+T\+::size}, \textbf{ storage\+Block\+\_\+\+T\+::slots}, and \textbf{ storage\+Block\+\_\+\+T\+::start}.



Referenced by \textbf{ block\+Mem\+\_\+\+C\+::block\+End()}, and \textbf{ print()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classstorageBlock__C_a2467b7e6f601f96efc42a6c32a023522_icgraph}
\end{center}
\end{figure}
\mbox{\label{classstorageBlock__C_ab118a805d45d5b6208fbd31dface7e39}} 
\index{storageBlock\_C@{storageBlock\_C}!blockSize@{blockSize}}
\index{blockSize@{blockSize}!storageBlock\_C@{storageBlock\_C}}
\doxysubsubsection{blockSize()}
{\footnotesize\ttfamily byte storage\+Block\+\_\+\+C\+::block\+Size (\begin{DoxyParamCaption}\item[{byte}]{id }\end{DoxyParamCaption})}



get the storage space size in bytes reserved for the block. 


\begin{DoxyParams}{Parameters}
{\em id} & The block id/array index. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
byte block size in bytes. 
\end{DoxyReturn}


Definition at line \textbf{ 37} of file \textbf{ store.\+cpp}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00037                                         \{}
\DoxyCodeLine{00038     \textcolor{keywordflow}{return} blocksA[ id ].slots * blocksA[ id ].size; \textcolor{comment}{//mem for block = number of slots * slot size.}}
\DoxyCodeLine{00039 \}}

\end{DoxyCode}


References \textbf{ blocksA}, \textbf{ storage\+Block\+\_\+\+T\+::size}, and \textbf{ storage\+Block\+\_\+\+T\+::slots}.



Referenced by \textbf{ block\+Mem\+\_\+\+C\+::block\+Size()}, and \textbf{ print()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classstorageBlock__C_ab118a805d45d5b6208fbd31dface7e39_icgraph}
\end{center}
\end{figure}
\mbox{\label{classstorageBlock__C_ad1486b9a48a2b2c4cb3cf16827cbb7a1}} 
\index{storageBlock\_C@{storageBlock\_C}!blockStart@{blockStart}}
\index{blockStart@{blockStart}!storageBlock\_C@{storageBlock\_C}}
\doxysubsubsection{blockStart()}
{\footnotesize\ttfamily word storage\+Block\+\_\+\+C\+::block\+Start (\begin{DoxyParamCaption}\item[{byte}]{block\+Id }\end{DoxyParamCaption})}



Get the storage block start address. 


\begin{DoxyParams}{Parameters}
{\em block\+Id} & Block id/array index \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
word 
\end{DoxyReturn}


Definition at line \textbf{ 122} of file \textbf{ store.\+cpp}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00122                                               \{}
\DoxyCodeLine{00123     \textcolor{keywordflow}{return} blocksA[ blockId ].start;}
\DoxyCodeLine{00124 \}}

\end{DoxyCode}


References \textbf{ blocksA}, and \textbf{ storage\+Block\+\_\+\+T\+::start}.



Referenced by \textbf{ block\+Mem\+\_\+\+C\+::block\+Start()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classstorageBlock__C_ad1486b9a48a2b2c4cb3cf16827cbb7a1_icgraph}
\end{center}
\end{figure}
\mbox{\label{classstorageBlock__C_acb749fa733b7000304b57fb659716497}} 
\index{storageBlock\_C@{storageBlock\_C}!getSlots@{getSlots}}
\index{getSlots@{getSlots}!storageBlock\_C@{storageBlock\_C}}
\doxysubsubsection{getSlots()}
{\footnotesize\ttfamily byte storage\+Block\+\_\+\+C\+::get\+Slots (\begin{DoxyParamCaption}\item[{byte}]{id }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 58} of file \textbf{ store.\+h}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00058 \{ \textcolor{keywordflow}{return} blocksA[id].slots; \}}

\end{DoxyCode}


References \textbf{ blocksA}, and \textbf{ storage\+Block\+\_\+\+T\+::slots}.



Referenced by \textbf{ block\+Mem\+\_\+\+C\+::get\+Slots()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=343pt]{classstorageBlock__C_acb749fa733b7000304b57fb659716497_icgraph}
\end{center}
\end{figure}
\mbox{\label{classstorageBlock__C_a0f4aa42b1755c6439528a6a6f72043f8}} 
\index{storageBlock\_C@{storageBlock\_C}!leaveFirst@{leaveFirst}}
\index{leaveFirst@{leaveFirst}!storageBlock\_C@{storageBlock\_C}}
\doxysubsubsection{leaveFirst()}
{\footnotesize\ttfamily void storage\+Block\+\_\+\+C\+::leave\+First (\begin{DoxyParamCaption}\item[{byte}]{i }\end{DoxyParamCaption})}



Set the address to start using storage at. 


\begin{DoxyParams}{Parameters}
{\em i} & The storage index/ memory address. \\
\hline
\end{DoxyParams}


Definition at line \textbf{ 61} of file \textbf{ store.\+cpp}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00061                                         \{}
\DoxyCodeLine{00062     nextStartAddr = i;\textcolor{comment}{// for eeprom the first address is 0 is if i = 15 there would be 15 unused(well by this) bytes.}}
\DoxyCodeLine{00063 \};}

\end{DoxyCode}


References \textbf{ next\+Start\+Addr}.

\mbox{\label{classstorageBlock__C_a5689bada4bede0c81ab36fe2f06cc9f0}} 
\index{storageBlock\_C@{storageBlock\_C}!print@{print}}
\index{print@{print}!storageBlock\_C@{storageBlock\_C}}
\doxysubsubsection{print()}
{\footnotesize\ttfamily void storage\+Block\+\_\+\+C\+::print (\begin{DoxyParamCaption}\item[{byte}]{id }\end{DoxyParamCaption})}



print info about the storage block to the serial. 


\begin{DoxyParams}{Parameters}
{\em id} & the id(array index) of the block to print the info about. \\
\hline
\end{DoxyParams}


Definition at line \textbf{ 70} of file \textbf{ store.\+cpp}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00070                                     \{}
\DoxyCodeLine{00071     io\_print( \textcolor{stringliteral}{"{} storage id: "{}} ); io\_print\_n( \textcolor{keywordtype}{id} );}
\DoxyCodeLine{00072     io\_print( \textcolor{stringliteral}{"{}, start address: "{}} ); io\_print\_n( blocksA[ \textcolor{keywordtype}{id} ].start );}
\DoxyCodeLine{00073     io\_print( \textcolor{stringliteral}{"{}, end addr: "{}} ); io\_print\_n( blockEnd( \textcolor{keywordtype}{id} ) );}
\DoxyCodeLine{00074     io\_print( \textcolor{stringliteral}{"{}, bytes used: "{}} ); io\_print\_n( blockSize( \textcolor{keywordtype}{id} ) );}
\DoxyCodeLine{00075 \}}

\end{DoxyCode}


References \textbf{ block\+End()}, \textbf{ blocksA}, and \textbf{ block\+Size()}.



Referenced by \textbf{ block\+Mem\+\_\+\+C\+::print()}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=346pt]{classstorageBlock__C_a5689bada4bede0c81ab36fe2f06cc9f0_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=309pt]{classstorageBlock__C_a5689bada4bede0c81ab36fe2f06cc9f0_icgraph}
\end{center}
\end{figure}
\mbox{\label{classstorageBlock__C_a769366c10cb4f7a77f9098bca7be6256}} 
\index{storageBlock\_C@{storageBlock\_C}!printMemUsage@{printMemUsage}}
\index{printMemUsage@{printMemUsage}!storageBlock\_C@{storageBlock\_C}}
\doxysubsubsection{printMemUsage()}
{\footnotesize\ttfamily void storage\+Block\+\_\+\+C\+::print\+Mem\+Usage (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Print storage mem usage.

Definition at line \textbf{ 77} of file \textbf{ store.\+cpp}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00077                                    \{}
\DoxyCodeLine{00078 \textcolor{preprocessor}{\#ifdef ATmega328P}}
\DoxyCodeLine{00079     io\_println( \textcolor{stringliteral}{"{}MCU = ATmega328P"{}} );}
\DoxyCodeLine{00080 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00081     io\_println( \textcolor{stringliteral}{"{}ATmega328P has 1kByte EEPROM, ATmega1280 and ATmega2560 4KB"{}} );}
\DoxyCodeLine{00082     \textcolor{comment}{//    io\_println( "{}EEPROM use:"{} );}}
\DoxyCodeLine{00083     io\_print( \textcolor{stringliteral}{"{}Storage used:\(\backslash\)n\(\backslash\)r\(\backslash\)tFor vars: "{}} );}
\DoxyCodeLine{00084     io\_print\_n( blocksA[ 0 ].start );}
\DoxyCodeLine{00085     \textcolor{comment}{//io\_print( "{}bytes, For switch sender = "{} );}}
\DoxyCodeLine{00086     \textcolor{comment}{//io\_println\_n( resMemForSwitchCon );}}
\DoxyCodeLine{00087     io\_print( \textcolor{stringliteral}{"{}bytes,\(\backslash\)n\(\backslash\)r\(\backslash\)tFor Blocks: "{}} );}
\DoxyCodeLine{00088     io\_println\_n( nextStartAddr -\/ blocksA[ 0 ].start );}
\DoxyCodeLine{00089     io\_print( \textcolor{stringliteral}{"{}\(\backslash\)tTotal EEPROM memory used in bytes = "{}} );}
\DoxyCodeLine{00090     io\_print\_n( nextStartAddr );}
\DoxyCodeLine{00091     io\_print( \textcolor{stringliteral}{"{}bytes, EEPROM memory left bytes = "{}} );}
\DoxyCodeLine{00092     io\_print\_n( ( mem\_eeprom -\/ ( nextStartAddr ) ) );}
\DoxyCodeLine{00093     io\_print( \textcolor{stringliteral}{"{}bytes, percentage left \(\backslash\)u2248 "{}} );\textcolor{comment}{//using this ≈ works to}}
\DoxyCodeLine{00094     io\_print\_n( ( ( mem\_eeprom -\/ ( nextStartAddr ) ) * 100ul ) / mem\_eeprom ); io\_println( \textcolor{stringliteral}{"{}\%"{}} );}
\DoxyCodeLine{00095 }
\DoxyCodeLine{00096 \}}

\end{DoxyCode}


References \textbf{ blocksA}, and \textbf{ next\+Start\+Addr}.

\mbox{\label{classstorageBlock__C_aee7a456279f8d306be97defb37320c35}} 
\index{storageBlock\_C@{storageBlock\_C}!readByte@{readByte}}
\index{readByte@{readByte}!storageBlock\_C@{storageBlock\_C}}
\doxysubsubsection{readByte()}
{\footnotesize\ttfamily byte storage\+Block\+\_\+\+C\+::read\+Byte (\begin{DoxyParamCaption}\item[{byte}]{block\+Id,  }\item[{byte}]{slot,  }\item[{byte}]{offset }\end{DoxyParamCaption})}



Read a byte of data from a storage block slot. 


\begin{DoxyParams}{Parameters}
{\em block\+Id} & the index the into the array holding the block info ie. (blocksA[block\+Id]). \\
\hline
{\em slot} & The slot number. \\
\hline
{\em offset} & The byte to read withing the slot starting at 0 for the first. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
byte 
\end{DoxyReturn}


Definition at line \textbf{ 134} of file \textbf{ store.\+cpp}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00134                                                                     \{}
\DoxyCodeLine{00135     word i;}
\DoxyCodeLine{00136     i = blocksA[ blockId ].start + ( slot * blocksA[ blockId ].size );}
\DoxyCodeLine{00137     \textcolor{keywordflow}{return} EEPROM.read( i );}
\DoxyCodeLine{00138 }
\DoxyCodeLine{00139 \}}

\end{DoxyCode}


References \textbf{ blocksA}, \textbf{ storage\+Block\+\_\+\+T\+::size}, and \textbf{ storage\+Block\+\_\+\+T\+::start}.



Referenced by \textbf{ block\+Mem\+\_\+\+C\+::read\+Byte()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classstorageBlock__C_aee7a456279f8d306be97defb37320c35_icgraph}
\end{center}
\end{figure}
\mbox{\label{classstorageBlock__C_a85ff9c2e220fa0a8e7c1d62f85a3cf39}} 
\index{storageBlock\_C@{storageBlock\_C}!readSlot@{readSlot}}
\index{readSlot@{readSlot}!storageBlock\_C@{storageBlock\_C}}
\doxysubsubsection{readSlot()}
{\footnotesize\ttfamily bool storage\+Block\+\_\+\+C\+::read\+Slot (\begin{DoxyParamCaption}\item[{byte}]{block\+Id,  }\item[{byte}]{slot,  }\item[{void $\ast$}]{r }\end{DoxyParamCaption})}



Read a var from permanent storage eg. EEPROM into a var/struct, copys mem of size = to the slot size given when add\+Block was called. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em block\+Id} & the block of storage, ie. the index to the array \\
\hline
\mbox{\texttt{ in}}  & {\em slot} & The slot to read, mem copy len is = the size of the rec/slot \\
\hline
\mbox{\texttt{ out}}  & {\em r} & pointer to the memory to copy the slot into. As not using templates need to make sure sizeof(var pointed to by r) $>$= slot size. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if no problems 

false if slot $>$ num of slots in block. 
\end{DoxyReturn}


Definition at line \textbf{ 152} of file \textbf{ store.\+cpp}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00152                                                                 \{}
\DoxyCodeLine{00153     word i, x;}
\DoxyCodeLine{00154     \textcolor{comment}{//io\_print( "{}, id: "{} ); io\_print\_n( blockId );// checked to = 1 for 1-\/wire.}}
\DoxyCodeLine{00155     \textcolor{comment}{//io\_print( "{}, slot: "{} ); io\_print\_n( slot );}}
\DoxyCodeLine{00156     \textcolor{comment}{//io\_print( "{}, \&blocksA:"{} ); io\_print\_n( ( word )\&blocksA );}}
\DoxyCodeLine{00157     \textcolor{comment}{//io\_print( "{}, \&this:"{} ); io\_print\_n( ( word )this );}}
\DoxyCodeLine{00158 }
\DoxyCodeLine{00159     \textcolor{comment}{//io\_print( "{}, .slots: "{} ); io\_print\_n( blocksA[ blockId ].slots );}}
\DoxyCodeLine{00160     \textcolor{comment}{//io\_print( "{}, sizeof(r):"{});io\_print\_n( sizeof(r) );}}
\DoxyCodeLine{00161     \textcolor{comment}{//io\_print( "{}, r:"{});io\_print\_n( (word)r );}}
\DoxyCodeLine{00162     \textcolor{comment}{//io\_print( "{}, ( byte* )r:"{}); io\_print\_n( (word)(( byte* )r) );}}
\DoxyCodeLine{00163 }
\DoxyCodeLine{00164     \textcolor{keywordflow}{if} ( slot > blocksA[ blockId ].slots ) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{00165     i = blocksA[ blockId ].start + ( slot * blocksA[ blockId ].size );}
\DoxyCodeLine{00166     \textcolor{comment}{//io\_print( "{}, i(EEPROM addr): "{} ); io\_print\_n( i );}}
\DoxyCodeLine{00167     \textcolor{keywordtype}{byte}* d = ( \textcolor{keywordtype}{byte}* )r;}
\DoxyCodeLine{00168     \textcolor{comment}{//io\_print( "{}, d:"{});io\_print\_n( (word)d );}}
\DoxyCodeLine{00169     \textcolor{keywordflow}{for} ( x = 0; x < blocksA[ blockId ].size; x++ ) \{}
\DoxyCodeLine{00170         d[ x ] = EEPROM.read( i + x );}
\DoxyCodeLine{00171         \textcolor{comment}{//io\_print( "{}."{} );}}
\DoxyCodeLine{00172     \}}
\DoxyCodeLine{00173     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{00174 \}}

\end{DoxyCode}


References \textbf{ blocksA}, \textbf{ storage\+Block\+\_\+\+T\+::size}, and \textbf{ storage\+Block\+\_\+\+T\+::start}.



Referenced by \textbf{ block\+Mem\+\_\+\+C\+::read\+Slot()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=345pt]{classstorageBlock__C_a85ff9c2e220fa0a8e7c1d62f85a3cf39_icgraph}
\end{center}
\end{figure}
\mbox{\label{classstorageBlock__C_abef785fcb0da67f1ca8dbf54cfc6491f}} 
\index{storageBlock\_C@{storageBlock\_C}!writeByte@{writeByte}}
\index{writeByte@{writeByte}!storageBlock\_C@{storageBlock\_C}}
\doxysubsubsection{writeByte()}
{\footnotesize\ttfamily bool storage\+Block\+\_\+\+C\+::write\+Byte (\begin{DoxyParamCaption}\item[{byte}]{block\+Id,  }\item[{byte}]{slot,  }\item[{byte}]{offset,  }\item[{byte}]{value }\end{DoxyParamCaption})}



Definition at line \textbf{ 196} of file \textbf{ store.\+cpp}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00196                                                                                 \{}
\DoxyCodeLine{00197      word i;}
\DoxyCodeLine{00198      i = blocksA[ blockId ].start + ( slot * blocksA[ blockId ].size ) + offset;}
\DoxyCodeLine{00199      EEPROM.update( i,  value);}
\DoxyCodeLine{00200      \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{00201 \}}

\end{DoxyCode}


References \textbf{ blocksA}, \textbf{ storage\+Block\+\_\+\+T\+::size}, and \textbf{ storage\+Block\+\_\+\+T\+::start}.



Referenced by \textbf{ block\+Mem\+\_\+\+C\+::write\+Byte()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classstorageBlock__C_abef785fcb0da67f1ca8dbf54cfc6491f_icgraph}
\end{center}
\end{figure}
\mbox{\label{classstorageBlock__C_a7e258c73d18c8939ab2fcab66fcf6a64}} 
\index{storageBlock\_C@{storageBlock\_C}!writeSlot@{writeSlot}}
\index{writeSlot@{writeSlot}!storageBlock\_C@{storageBlock\_C}}
\doxysubsubsection{writeSlot()}
{\footnotesize\ttfamily bool storage\+Block\+\_\+\+C\+::write\+Slot (\begin{DoxyParamCaption}\item[{byte}]{block\+Id,  }\item[{byte}]{slot,  }\item[{void $\ast$}]{r }\end{DoxyParamCaption})}



Write a var into permanent storage eg. EEPROM into a var/struct, copys mem of size = to the slot size given when add\+Block was called. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em block\+Id} & the block of storage, ie. the index to the array \\
\hline
\mbox{\texttt{ in}}  & {\em slot} & The slot to update, mem copy len is = the size of the rec/slot \\
\hline
\mbox{\texttt{ out}}  & {\em r} & pointer to the memory to copy into the slot. As not using templates need to make sure sizeof(var pointed to by r) $>$= slot size. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if no problems 

false if slot $>$ num of slots in block. 
\end{DoxyReturn}


Definition at line \textbf{ 185} of file \textbf{ store.\+cpp}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00185                                                                  \{}
\DoxyCodeLine{00186     word i, x;}
\DoxyCodeLine{00187     \textcolor{keywordflow}{if} ( slot > blocksA[ blockId ].slots ) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{00188     i = blocksA[ blockId ].start + ( slot * blocksA[ blockId ].size );}
\DoxyCodeLine{00189     \textcolor{keywordtype}{byte}* d = ( \textcolor{keywordtype}{byte}* )r;}
\DoxyCodeLine{00190     \textcolor{keywordflow}{for} ( x = 0; x < blocksA[ blockId ].size; x++ ) \{}
\DoxyCodeLine{00191         EEPROM.update( i + x, d[ x ] );}
\DoxyCodeLine{00192     \}}
\DoxyCodeLine{00193     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{00194 \}}

\end{DoxyCode}


References \textbf{ blocksA}, \textbf{ storage\+Block\+\_\+\+T\+::size}, and \textbf{ storage\+Block\+\_\+\+T\+::start}.



Referenced by \textbf{ block\+Mem\+\_\+\+C\+::write\+Slot()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classstorageBlock__C_a7e258c73d18c8939ab2fcab66fcf6a64_icgraph}
\end{center}
\end{figure}


\doxysubsection{Member Data Documentation}
\mbox{\label{classstorageBlock__C_a9069a91d9228649e3d3f67b5f40e182a}} 
\index{storageBlock\_C@{storageBlock\_C}!blocksA@{blocksA}}
\index{blocksA@{blocksA}!storageBlock\_C@{storageBlock\_C}}
\doxysubsubsection{blocksA}
{\footnotesize\ttfamily \textbf{ storage\+Block\+\_\+T}$\ast$ storage\+Block\+\_\+\+C\+::blocksA}



No. of elements of blocksA[] used. 



Definition at line \textbf{ 44} of file \textbf{ store.\+h}.



Referenced by \textbf{ add\+Block()}, \textbf{ block\+End()}, \textbf{ block\+Size()}, \textbf{ block\+Start()}, \textbf{ get\+Slots()}, \textbf{ print()}, \textbf{ print\+Mem\+Usage()}, \textbf{ read\+Byte()}, \textbf{ read\+Slot()}, \textbf{ block\+Mem\+\_\+\+C\+::slot\+Size()}, \textbf{ storage\+Block\+\_\+\+C()}, \textbf{ write\+Byte()}, and \textbf{ write\+Slot()}.

\mbox{\label{classstorageBlock__C_ab6449bda89cd0dab792e60e5ee862939}} 
\index{storageBlock\_C@{storageBlock\_C}!maxBlocks@{maxBlocks}}
\index{maxBlocks@{maxBlocks}!storageBlock\_C@{storageBlock\_C}}
\doxysubsubsection{maxBlocks}
{\footnotesize\ttfamily byte storage\+Block\+\_\+\+C\+::max\+Blocks\hspace{0.3cm}{\ttfamily [private]}}



The address/index to start at for any new block. 



Definition at line \textbf{ 41} of file \textbf{ store.\+h}.



Referenced by \textbf{ storage\+Block\+\_\+\+C()}.

\mbox{\label{classstorageBlock__C_a8534147de81cd1c257a0ec727440213c}} 
\index{storageBlock\_C@{storageBlock\_C}!nextStartAddr@{nextStartAddr}}
\index{nextStartAddr@{nextStartAddr}!storageBlock\_C@{storageBlock\_C}}
\doxysubsubsection{nextStartAddr}
{\footnotesize\ttfamily uint16\+\_\+t storage\+Block\+\_\+\+C\+::next\+Start\+Addr\hspace{0.3cm}{\ttfamily [private]}}



Definition at line \textbf{ 40} of file \textbf{ store.\+h}.



Referenced by \textbf{ add\+Block()}, \textbf{ leave\+First()}, \textbf{ print\+Mem\+Usage()}, and \textbf{ storage\+Block\+\_\+\+C()}.

\mbox{\label{classstorageBlock__C_af11fee6180446c962384ebe4c5d8eb11}} 
\index{storageBlock\_C@{storageBlock\_C}!slotsUsed@{slotsUsed}}
\index{slotsUsed@{slotsUsed}!storageBlock\_C@{storageBlock\_C}}
\doxysubsubsection{slotsUsed}
{\footnotesize\ttfamily byte storage\+Block\+\_\+\+C\+::slots\+Used = 0\hspace{0.3cm}{\ttfamily [private]}}



The max No. Blocks. The number of array elements in the array used to store the block info in (blocksA). 



Definition at line \textbf{ 42} of file \textbf{ store.\+h}.



Referenced by \textbf{ add\+Block()}.



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
src/\textbf{ store.\+h}\item 
src/\textbf{ store.\+cpp}\end{DoxyCompactItemize}
